
# Digno Dev Notes

## Standard Development Startup (ALWAYS REFERENCE THIS)

Canonical way to run the full stack (frontend + backend + db):

```bash
docker-compose up --build
```

Services:
- frontend  -> http://localhost:3000 (Next.js dev server)
- web       -> http://localhost:8000 (Django runserver)
- db        -> Postgres 15 (hostname inside network: db)

Do NOT normally run `npm run dev` (frontend) or `python manage.py runserver` (backend) directly on the host—those bypass container networking & env consistency.

### Quick Commands
Migrations:
```bash
docker-compose exec web python manage.py makemigrations
docker-compose exec web python manage.py migrate
```

Create superuser:
```bash
docker-compose exec web python manage.py createsuperuser
```

Add frontend dependency:
```bash
docker-compose exec frontend sh
npm install <package>
```

Add backend dependency:
1. Edit `backend/requirements.txt`
2. Rebuild web layer:
```bash
docker-compose build web
docker-compose up -d web
```

Clean rebuild (fix cache, perms, node_modules issues):
```bash
docker-compose down -v
docker-compose up --build
```

Tail logs:
```bash
docker-compose logs -f web
docker-compose logs -f frontend
```

### Health Checks
```bash
docker-compose ps
curl -I http://localhost:3000
curl -I http://localhost:8000/api/
```

### Permission / EPERM on .next
Should be solved by non-root user in updated Dockerfile. If it recurs: clean rebuild (above).

### API Base URL Logic (current)
Inside Docker: axios uses `http://web:8000/api/` directly.
Outside Docker (future optional improvement): allow `NEXT_PUBLIC_API_URL` or fallback to rewrite `/api/*`.

---

## Docker Networking for API Calls

- In Docker Compose, the frontend (Next.js) and backend (Django) containers communicate using service names as hostnames.
- The axios client in `frontend/src/lib/api.ts` is hardcoded to use `http://web:8000/api/` as the base URL for all API calls.
- This ensures reliable connectivity in Docker, since `web` is the backend service name.
- For local development (outside Docker), you can switch the baseURL to `/api/` and use Next.js rewrites, or set `NEXT_PUBLIC_API_URL` to `http://localhost:8000/api/`.


## API Proxy Status

- As of September 23, 2025, the API proxy is working correctly.
- You can access your Django API at http://localhost:3000/api/articles/ and receive a valid JSON response from the backend via the Next.js rewrite.

## Debugging API Connectivity

- To test API connectivity from the frontend container:
  1. Open a shell in the frontend container:
     ```sh
     docker-compose exec frontend sh
     ```
  2. Run:
     ```sh
     curl -v http://web:8000/api/articles/
     ```
  3. You should see a JSON response from the backend if networking is correct.

## Reference
- See `frontend/src/lib/api.ts` for the current axios configuration.
- See `frontend/next.config.mjs` for Next.js rewrite rules (used for local/dev, not Docker).

Always consult this `notes.txt` before starting or troubleshooting.

## October 11, 2025 - API 500 Error: Incorrect Frontend API Configuration
- Cause: Frontend API client was using Next.js rewrites (`/api/`) instead of direct backend URL (`http://web:8000/api/`) in Docker environment. Next.js rewrites don't work reliably for container-to-container communication.
- Root Issue: The frontend `api.ts` was hardcoded to use `/api/` baseURL, but Docker containers need direct service URLs for reliable networking.
- Solution: Updated `frontend/src/lib/api.ts` to detect Docker environment and use `http://web:8000/api/` directly when `DOCKER=true`, falling back to `/api/` rewrites for local development.
- Backend Verification: `curl http://web:8000/api/articles/` returns 200 OK with valid JSON - backend was working correctly.
- Status: ✅ FIXED

## Docker API Communication Best Practices
- ✅ In Docker: Frontend should use direct backend service URLs (`http://web:8000/api/`)
- ✅ Outside Docker: Frontend can use Next.js rewrites (`/api/` → `http://localhost:8000/api/`)
- ✅ Always verify backend endpoints work with direct curl before debugging frontend
- ✅ Use environment detection to switch between Docker and local development modes
